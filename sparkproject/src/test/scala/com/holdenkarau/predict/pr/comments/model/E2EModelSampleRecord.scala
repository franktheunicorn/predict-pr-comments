package com.holdenkarau.predict.pr.comments.sparkProject.ml
object E2EModelSampleRecord {
  val record =
"{\"pull_request_url\":\"https://api.github.com/repos/Dreamacro/clash/pulls/96\",\"pull_patch_url\":\"https://github.com/Dreamacro/clash/pull/96.patch\",\"comments_positions\":[42,null],\"comments_original\":[42,42],\"comment_file_paths\":[\"rules/from_ipcidr.go\",\"rules/from_ipcidr.go\"],\"comment_commit_ids\":[\"de976981dff604f3f41167012ddb82b3e0c90e6d\",\"0b44c7a83aa400caf5db40975a75428682431309\"],\"patch\":\"From 97d57259eaf8ca29ce56a194de110d526c2d1629 Mon Sep 17 00:00:00 2001\\nFrom: songchenwen <me@songchenwen.com>\\nDate: Wed, 16 Jan 2019 19:12:23 +0800\\nSubject: [PATCH] Feature: SOURCE-IP-CIDR rule type\\n\\n---\\n README.md                  |  1 +\\n adapters/inbound/http.go   |  4 +++-\\n adapters/inbound/https.go  |  4 +++-\\n adapters/inbound/socket.go |  1 +\\n adapters/inbound/util.go   |  7 +++++++\\n config/config.go           |  4 +++-\\n constant/metadata.go       |  1 +\\n constant/rule.go           |  3 +++\\n rules/ipcidr.go            | 23 ++++++++++++++---------\\n tunnel/tunnel.go           |  6 +++---\\n 10 files changed, 39 insertions(+), 15 deletions(-)\\n\\ndiff --git a/README.md b/README.md\\nindex 31c2bb2..ec256ba 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -170,6 +170,7 @@ Rule:\\n - DOMAIN,google.com,Proxy\\n - DOMAIN-SUFFIX,ad.com,REJECT\\n - IP-CIDR,127.0.0.0/8,DIRECT\\n+- SOURCE-IP-CIDR,192.168.1.201/32,DIRECT\\n - GEOIP,CN,DIRECT\\n # FINAL would remove after prerelease\\n # you also can use `FINAL,Proxy` or `FINAL,,Proxy` now\\ndiff --git a/adapters/inbound/http.go b/adapters/inbound/http.go\\nindex 01aa14b..8aa21e7 100644\\n--- a/adapters/inbound/http.go\\n+++ b/adapters/inbound/http.go\\n@@ -32,8 +32,10 @@ func (h *HTTPAdapter) Conn() net.Conn {\\n \\n // NewHTTP is HTTPAdapter generator\\n func NewHTTP(request *http.Request, conn net.Conn) *HTTPAdapter {\\n+\\tmetadata := parseHTTPAddr(request)\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\treturn &HTTPAdapter{\\n-\\t\\tmetadata: parseHTTPAddr(request),\\n+\\t\\tmetadata: metadata,\\n \\t\\tR:        request,\\n \\t\\tconn:     conn,\\n \\t}\\ndiff --git a/adapters/inbound/https.go b/adapters/inbound/https.go\\nindex 6e36180..e951268 100644\\n--- a/adapters/inbound/https.go\\n+++ b/adapters/inbound/https.go\\n@@ -7,8 +7,10 @@ import (\\n \\n // NewHTTPS is HTTPAdapter generator\\n func NewHTTPS(request *http.Request, conn net.Conn) *SocketAdapter {\\n+\\tmetadata := parseHTTPAddr(request)\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\treturn &SocketAdapter{\\n-\\t\\tmetadata: parseHTTPAddr(request),\\n+\\t\\tmetadata: metadata,\\n \\t\\tconn:     conn,\\n \\t}\\n }\\ndiff --git a/adapters/inbound/socket.go b/adapters/inbound/socket.go\\nindex 8c0ef49..66f13f6 100644\\n--- a/adapters/inbound/socket.go\\n+++ b/adapters/inbound/socket.go\\n@@ -32,6 +32,7 @@ func (s *SocketAdapter) Conn() net.Conn {\\n func NewSocket(target socks.Addr, conn net.Conn, source C.SourceType) *SocketAdapter {\\n \\tmetadata := parseSocksAddr(target)\\n \\tmetadata.Source = source\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\n \\treturn &SocketAdapter{\\n \\t\\tconn:     conn,\\ndiff --git a/adapters/inbound/util.go b/adapters/inbound/util.go\\nindex a1f5cd0..b059920 100644\\n--- a/adapters/inbound/util.go\\n+++ b/adapters/inbound/util.go\\n@@ -61,3 +61,10 @@ func parseHTTPAddr(request *http.Request) *C.Metadata {\\n \\n \\treturn metadata\\n }\\n+\\n+func parseSourceIP(conn net.Conn) *net.IP {\\n+\\tif addr, ok := conn.RemoteAddr().(*net.TCPAddr); ok {\\n+\\t\\treturn &addr.IP\\n+\\t}\\n+\\treturn nil\\n+}\\ndiff --git a/config/config.go b/config/config.go\\nindex 95f2772..979da3e 100644\\n--- a/config/config.go\\n+++ b/config/config.go\\n@@ -338,7 +338,9 @@ func parseRules(cfg *rawConfig) ([]C.Rule, error) {\\n \\t\\tcase \\\"GEOIP\\\":\\n \\t\\t\\trules = append(rules, R.NewGEOIP(payload, target))\\n \\t\\tcase \\\"IP-CIDR\\\", \\\"IP-CIDR6\\\":\\n-\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target))\\n+\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target, false))\\n+\\t\\tcase \\\"SOURCE-IP-CIDR\\\":\\n+\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target, true))\\n \\t\\tcase \\\"MATCH\\\":\\n \\t\\t\\tfallthrough\\n \\t\\tcase \\\"FINAL\\\":\\ndiff --git a/constant/metadata.go b/constant/metadata.go\\nindex 1cb1903..d8c371e 100644\\n--- a/constant/metadata.go\\n+++ b/constant/metadata.go\\n@@ -33,6 +33,7 @@ type SourceType int\\n type Metadata struct {\\n \\tNetWork  NetWork\\n \\tSource   SourceType\\n+\\tSourceIP *net.IP\\n \\tAddrType int\\n \\tHost     string\\n \\tIP       *net.IP\\ndiff --git a/constant/rule.go b/constant/rule.go\\nindex 1a8f5f9..ba28750 100644\\n--- a/constant/rule.go\\n+++ b/constant/rule.go\\n@@ -7,6 +7,7 @@ const (\\n \\tDomainKeyword\\n \\tGEOIP\\n \\tIPCIDR\\n+\\tSourceIPCIDR\\n \\tFINAL\\n )\\n \\n@@ -24,6 +25,8 @@ func (rt RuleType) String() string {\\n \\t\\treturn \\\"GEOIP\\\"\\n \\tcase IPCIDR:\\n \\t\\treturn \\\"IPCIDR\\\"\\n+\\tcase SourceIPCIDR:\\n+\\t\\treturn \\\"SourceIPCIDR\\\"\\n \\tcase FINAL:\\n \\t\\treturn \\\"FINAL\\\"\\n \\tdefault:\\ndiff --git a/rules/ipcidr.go b/rules/ipcidr.go\\nindex fe1a9d9..597ac3e 100644\\n--- a/rules/ipcidr.go\\n+++ b/rules/ipcidr.go\\n@@ -7,20 +7,24 @@ import (\\n )\\n \\n type IPCIDR struct {\\n-\\tipnet   *net.IPNet\\n-\\tadapter string\\n+\\tipnet      *net.IPNet\\n+\\tadapter    string\\n+\\tisSourceIP bool\\n }\\n \\n func (i *IPCIDR) RuleType() C.RuleType {\\n+\\tif i.isSourceIP {\\n+\\t\\treturn C.SourceIPCIDR\\n+\\t}\\n \\treturn C.IPCIDR\\n }\\n \\n func (i *IPCIDR) IsMatch(metadata *C.Metadata) bool {\\n-\\tif metadata.IP == nil {\\n-\\t\\treturn false\\n+\\tip := metadata.IP\\n+\\tif i.isSourceIP {\\n+\\t\\tip = metadata.SourceIP\\n \\t}\\n-\\n-\\treturn i.ipnet.Contains(*metadata.IP)\\n+\\treturn i.ipnet.Contains(*ip)\\n }\\n \\n func (i *IPCIDR) Adapter() string {\\n@@ -31,12 +35,13 @@ func (i *IPCIDR) Payload() string {\\n \\treturn i.ipnet.String()\\n }\\n \\n-func NewIPCIDR(s string, adapter string) *IPCIDR {\\n+func NewIPCIDR(s string, adapter string, isSourceIP bool) *IPCIDR {\\n \\t_, ipnet, err := net.ParseCIDR(s)\\n \\tif err != nil {\\n \\t}\\n \\treturn &IPCIDR{\\n-\\t\\tipnet:   ipnet,\\n-\\t\\tadapter: adapter,\\n+\\t\\tipnet:      ipnet,\\n+\\t\\tadapter:    adapter,\\n+\\t\\tisSourceIP: isSourceIP,\\n \\t}\\n }\\ndiff --git a/tunnel/tunnel.go b/tunnel/tunnel.go\\nindex 0b4e4ff..97eb1d8 100644\\n--- a/tunnel/tunnel.go\\n+++ b/tunnel/tunnel.go\\n@@ -134,7 +134,7 @@ func (t *Tunnel) handleConn(localConn C.ServerAdapter) {\\n \\t}\\n \\tremoConn, err := proxy.Generator(metadata)\\n \\tif err != nil {\\n-\\t\\tlog.Warnln(\\\"Proxy[%s] connect [%s] error: %s\\\", proxy.Name(), metadata.String(), err.Error())\\n+\\t\\tlog.Warnln(\\\"Proxy[%s] connect [%s --> %s] error: %s\\\", proxy.Name(), metadata.SourceIP.String(), metadata.String(), err.Error())\\n \\t\\treturn\\n \\t}\\n \\tdefer remoConn.Close()\\n@@ -157,11 +157,11 @@ func (t *Tunnel) match(metadata *C.Metadata) C.Proxy {\\n \\t\\t\\tif !ok {\\n \\t\\t\\t\\tcontinue\\n \\t\\t\\t}\\n-\\t\\t\\tlog.Infoln(\\\"%v match %s using %s\\\", metadata.String(), rule.RuleType().String(), rule.Adapter())\\n+\\t\\t\\tlog.Infoln(\\\"%s --> %v match %s using %s\\\", metadata.SourceIP.String(), metadata.String(), rule.RuleType().String(), rule.Adapter())\\n \\t\\t\\treturn a\\n \\t\\t}\\n \\t}\\n-\\tlog.Infoln(\\\"%v doesn\'t match any rule using DIRECT\\\", metadata.String())\\n+\\tlog.Infoln(\\\"%s --> %v doesn\'t match any rule using DIRECT\\\", metadata.SourceIP.String(), metadata.String())\\n \\treturn t.proxies[\\\"DIRECT\\\"]\\n }\\n \\n\",\"diff\":\"diff --git a/README.md b/README.md\\nindex 31c2bb2..ec256ba 100644\\n--- a/README.md\\n+++ b/README.md\\n@@ -170,6 +170,7 @@ Rule:\\n - DOMAIN,google.com,Proxy\\n - DOMAIN-SUFFIX,ad.com,REJECT\\n - IP-CIDR,127.0.0.0/8,DIRECT\\n+- SOURCE-IP-CIDR,192.168.1.201/32,DIRECT\\n - GEOIP,CN,DIRECT\\n # FINAL would remove after prerelease\\n # you also can use `FINAL,Proxy` or `FINAL,,Proxy` now\\ndiff --git a/adapters/inbound/http.go b/adapters/inbound/http.go\\nindex 01aa14b..8aa21e7 100644\\n--- a/adapters/inbound/http.go\\n+++ b/adapters/inbound/http.go\\n@@ -32,8 +32,10 @@ func (h *HTTPAdapter) Conn() net.Conn {\\n \\n // NewHTTP is HTTPAdapter generator\\n func NewHTTP(request *http.Request, conn net.Conn) *HTTPAdapter {\\n+\\tmetadata := parseHTTPAddr(request)\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\treturn &HTTPAdapter{\\n-\\t\\tmetadata: parseHTTPAddr(request),\\n+\\t\\tmetadata: metadata,\\n \\t\\tR:        request,\\n \\t\\tconn:     conn,\\n \\t}\\ndiff --git a/adapters/inbound/https.go b/adapters/inbound/https.go\\nindex 6e36180..e951268 100644\\n--- a/adapters/inbound/https.go\\n+++ b/adapters/inbound/https.go\\n@@ -7,8 +7,10 @@ import (\\n \\n // NewHTTPS is HTTPAdapter generator\\n func NewHTTPS(request *http.Request, conn net.Conn) *SocketAdapter {\\n+\\tmetadata := parseHTTPAddr(request)\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\treturn &SocketAdapter{\\n-\\t\\tmetadata: parseHTTPAddr(request),\\n+\\t\\tmetadata: metadata,\\n \\t\\tconn:     conn,\\n \\t}\\n }\\ndiff --git a/adapters/inbound/socket.go b/adapters/inbound/socket.go\\nindex 8c0ef49..66f13f6 100644\\n--- a/adapters/inbound/socket.go\\n+++ b/adapters/inbound/socket.go\\n@@ -32,6 +32,7 @@ func (s *SocketAdapter) Conn() net.Conn {\\n func NewSocket(target socks.Addr, conn net.Conn, source C.SourceType) *SocketAdapter {\\n \\tmetadata := parseSocksAddr(target)\\n \\tmetadata.Source = source\\n+\\tmetadata.SourceIP = parseSourceIP(conn)\\n \\n \\treturn &SocketAdapter{\\n \\t\\tconn:     conn,\\ndiff --git a/adapters/inbound/util.go b/adapters/inbound/util.go\\nindex a1f5cd0..b059920 100644\\n--- a/adapters/inbound/util.go\\n+++ b/adapters/inbound/util.go\\n@@ -61,3 +61,10 @@ func parseHTTPAddr(request *http.Request) *C.Metadata {\\n \\n \\treturn metadata\\n }\\n+\\n+func parseSourceIP(conn net.Conn) *net.IP {\\n+\\tif addr, ok := conn.RemoteAddr().(*net.TCPAddr); ok {\\n+\\t\\treturn &addr.IP\\n+\\t}\\n+\\treturn nil\\n+}\\ndiff --git a/config/config.go b/config/config.go\\nindex 95f2772..979da3e 100644\\n--- a/config/config.go\\n+++ b/config/config.go\\n@@ -338,7 +338,9 @@ func parseRules(cfg *rawConfig) ([]C.Rule, error) {\\n \\t\\tcase \\\"GEOIP\\\":\\n \\t\\t\\trules = append(rules, R.NewGEOIP(payload, target))\\n \\t\\tcase \\\"IP-CIDR\\\", \\\"IP-CIDR6\\\":\\n-\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target))\\n+\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target, false))\\n+\\t\\tcase \\\"SOURCE-IP-CIDR\\\":\\n+\\t\\t\\trules = append(rules, R.NewIPCIDR(payload, target, true))\\n \\t\\tcase \\\"MATCH\\\":\\n \\t\\t\\tfallthrough\\n \\t\\tcase \\\"FINAL\\\":\\ndiff --git a/constant/metadata.go b/constant/metadata.go\\nindex 1cb1903..d8c371e 100644\\n--- a/constant/metadata.go\\n+++ b/constant/metadata.go\\n@@ -33,6 +33,7 @@ type SourceType int\\n type Metadata struct {\\n \\tNetWork  NetWork\\n \\tSource   SourceType\\n+\\tSourceIP *net.IP\\n \\tAddrType int\\n \\tHost     string\\n \\tIP       *net.IP\\ndiff --git a/constant/rule.go b/constant/rule.go\\nindex 1a8f5f9..ba28750 100644\\n--- a/constant/rule.go\\n+++ b/constant/rule.go\\n@@ -7,6 +7,7 @@ const (\\n \\tDomainKeyword\\n \\tGEOIP\\n \\tIPCIDR\\n+\\tSourceIPCIDR\\n \\tFINAL\\n )\\n \\n@@ -24,6 +25,8 @@ func (rt RuleType) String() string {\\n \\t\\treturn \\\"GEOIP\\\"\\n \\tcase IPCIDR:\\n \\t\\treturn \\\"IPCIDR\\\"\\n+\\tcase SourceIPCIDR:\\n+\\t\\treturn \\\"SourceIPCIDR\\\"\\n \\tcase FINAL:\\n \\t\\treturn \\\"FINAL\\\"\\n \\tdefault:\\ndiff --git a/rules/ipcidr.go b/rules/ipcidr.go\\nindex fe1a9d9..597ac3e 100644\\n--- a/rules/ipcidr.go\\n+++ b/rules/ipcidr.go\\n@@ -7,20 +7,24 @@ import (\\n )\\n \\n type IPCIDR struct {\\n-\\tipnet   *net.IPNet\\n-\\tadapter string\\n+\\tipnet      *net.IPNet\\n+\\tadapter    string\\n+\\tisSourceIP bool\\n }\\n \\n func (i *IPCIDR) RuleType() C.RuleType {\\n+\\tif i.isSourceIP {\\n+\\t\\treturn C.SourceIPCIDR\\n+\\t}\\n \\treturn C.IPCIDR\\n }\\n \\n func (i *IPCIDR) IsMatch(metadata *C.Metadata) bool {\\n-\\tif metadata.IP == nil {\\n-\\t\\treturn false\\n+\\tip := metadata.IP\\n+\\tif i.isSourceIP {\\n+\\t\\tip = metadata.SourceIP\\n \\t}\\n-\\n-\\treturn i.ipnet.Contains(*metadata.IP)\\n+\\treturn i.ipnet.Contains(*ip)\\n }\\n \\n func (i *IPCIDR) Adapter() string {\\n@@ -31,12 +35,13 @@ func (i *IPCIDR) Payload() string {\\n \\treturn i.ipnet.String()\\n }\\n \\n-func NewIPCIDR(s string, adapter string) *IPCIDR {\\n+func NewIPCIDR(s string, adapter string, isSourceIP bool) *IPCIDR {\\n \\t_, ipnet, err := net.ParseCIDR(s)\\n \\tif err != nil {\\n \\t}\\n \\treturn &IPCIDR{\\n-\\t\\tipnet:   ipnet,\\n-\\t\\tadapter: adapter,\\n+\\t\\tipnet:      ipnet,\\n+\\t\\tadapter:    adapter,\\n+\\t\\tisSourceIP: isSourceIP,\\n \\t}\\n }\\ndiff --git a/tunnel/tunnel.go b/tunnel/tunnel.go\\nindex 0b4e4ff..97eb1d8 100644\\n--- a/tunnel/tunnel.go\\n+++ b/tunnel/tunnel.go\\n@@ -134,7 +134,7 @@ func (t *Tunnel) handleConn(localConn C.ServerAdapter) {\\n \\t}\\n \\tremoConn, err := proxy.Generator(metadata)\\n \\tif err != nil {\\n-\\t\\tlog.Warnln(\\\"Proxy[%s] connect [%s] error: %s\\\", proxy.Name(), metadata.String(), err.Error())\\n+\\t\\tlog.Warnln(\\\"Proxy[%s] connect [%s --> %s] error: %s\\\", proxy.Name(), metadata.SourceIP.String(), metadata.String(), err.Error())\\n \\t\\treturn\\n \\t}\\n \\tdefer remoConn.Close()\\n@@ -157,11 +157,11 @@ func (t *Tunnel) match(metadata *C.Metadata) C.Proxy {\\n \\t\\t\\tif !ok {\\n \\t\\t\\t\\tcontinue\\n \\t\\t\\t}\\n-\\t\\t\\tlog.Infoln(\\\"%v match %s using %s\\\", metadata.String(), rule.RuleType().String(), rule.Adapter())\\n+\\t\\t\\tlog.Infoln(\\\"%s --> %v match %s using %s\\\", metadata.SourceIP.String(), metadata.String(), rule.RuleType().String(), rule.Adapter())\\n \\t\\t\\treturn a\\n \\t\\t}\\n \\t}\\n-\\tlog.Infoln(\\\"%v doesn\'t match any rule using DIRECT\\\", metadata.String())\\n+\\tlog.Infoln(\\\"%s --> %v doesn\'t match any rule using DIRECT\\\", metadata.SourceIP.String(), metadata.String())\\n \\treturn t.proxies[\\\"DIRECT\\\"]\\n }\\n \\n\"}"
}
